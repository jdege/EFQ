@page

<partial name="_DemoMenu" />

<p>
    This is a collection of simple demos exploring the motivation behind and the use of
    <a href="https://github.com/jdege/EFQ">EFQ</a> -
    a class designed to allow Entity Framework queries to be constructed dynamically in code,
    and to be serialized in whole and in part for storage in databases, passed between client
    and server, etc.
</p>
<p>
    The task we're addressing, in the initial demos, is presenting the user with a query
    form in which the user can choose a Artist and/or a Customer from select lists, click "Search",
    and see a table containing information about the Tracks associated with the selected Artist, Customer,
    or both.
</p>
<p>
    The problem is building a query that might contain a comparison against ArtistID, might contain a
    comparison against CustomerID, or might contain both.
</p>
<p>
    The Demos:
<ol>
    <li><a asp-controller="SqlStatement">Sql Statements</a> - When using ADO, a query is simply a string containing SQL,
        which we can build up using string concatenation.</li>

    <li><a asp-controller="EntityFramework">Entity Framework</a> - With EF, in the simple case you can build up a query
        using
        IQueryable obects.</li>
    <li>
        <a asp-controller="PredicateBuilder">Predicate Builder</a> -
        Pete Montgomery's <a
            href="https://petemontgomery.wordpress.com/2011/02/10/a-universal-predicatebuilder/">PredicateBuilder</a>
        will allow you to construct a query from pieces in more complicated ways that using plain EF.
    </li>
    <li>
        <a asp-controller="PlainEFQ">Plain EFQ</a> -
        EFQ wraps PredicateBuilder, and when used directly works much the same way.
    </li>
    <li>
        <a asp-controller="EFQOnServer">EFQ on server</a> - The change here is to use AJAX.
        The MVC controller returns a view that contains no data.
        We use Javascript to call Web API endpoints to populate the &lt;select&gt;s.
        The handler on the Search button calls a Web API endpoint passing ArtistID and CustomerId, which returns the
        TrackModels.
    </li>
    <li>
        <a asp-controller="EFQOnClient">EFQ on client</a> - This still uses AJAX.
        The difference here is that we've attached EFQ objects to each element in the &lt;select&gt;s.
        The handler on the Search button builds an EFQ object that ands the EFQ objects of the selected elements,
        and passes that to the Web API endpoint.
    </li>
</ol>
</p>
